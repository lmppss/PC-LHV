# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZkgJpsrPLf54vXV3wMqcJXu2RLl27OGj
"""

import streamlit as st
import numpy as np
import pandas as pd
import joblib
import datetime
import pytz
import plotly.express as px
import os

# Cargar el modelo .pkl
modelo = joblib.load("PC_0.8722_12.04.pkl")

# Archivo temporal para guardar predicciones
historial_path = "historial_predicciones.csv"
if not os.path.exists(historial_path):
    pd.DataFrame(columns=["FechaHora", "Cenizas", "PC"]).to_csv(historial_path, index=False)

# TÃ­tulo de la app
st.title("ğŸ”¥ PredicciÃ³n del Poder CalorÃ­fico del CarbÃ³n")
st.markdown("Ingrese los datos manualmente o pegue una fila completa separada por **coma, espacio o tabulaciÃ³n**.")

# OpciÃ³n de entrada rÃ¡pida
st.subheader("ğŸ“‹ Entrada rÃ¡pida (una lÃ­nea completa)")
entrada_linea = st.text_input("Pegue aquÃ­ una fila completa con los 11 valores en orden:")

# BotÃ³n para activar la entrada manual
mostrar_entrada_manual = st.button("ğŸ“ Mostrar entrada manual")

# Si se presiona el botÃ³n, se muestran los campos de entrada manual
if mostrar_entrada_manual:
    cenizas_bs = st.number_input("Cenizas (BS) (%)", min_value=0.0)
    sio2 = st.number_input("SiO2 ash (%)", min_value=0.0)
    al2o3 = st.number_input("Al2O3 ash (%)", min_value=0.0)
    fe2o3 = st.number_input("Fe2O3 ash (%)", min_value=0.0)
    cao = st.number_input("CaO ash (%)", min_value=0.0)
    mgo = st.number_input("MgO ash (%)", min_value=0.0)
    so3 = st.number_input("SO3 ash (%)", min_value=0.0)
    na2o = st.number_input("Na2O ash (%)", min_value=0.0)
    k2o = st.number_input("K2O ash (%)", min_value=0.0)
    s_carbon = st.number_input("S carbÃ³n (%)", min_value=0.0)
    cl_carbon = st.number_input("Cl carbÃ³n (%)", min_value=0.0)

# BotÃ³n de predicciÃ³n
if st.button("ğŸ”® Predecir Poder CalorÃ­fico"):
    if entrada_linea:
        # Detectar separador
        if "," in entrada_linea:
            sep = ","
        elif "\t" in entrada_linea:
            sep = "\t"
        else:
            sep = " "
        try:
            valores = list(map(float, entrada_linea.strip().split(sep)))
            if len(valores) != 11:
                st.error("âš ï¸ Debe ingresar exactamente 11 valores.")
                st.stop()
        except:
            st.error("âš ï¸ Error en el formato de la lÃ­nea pegada.")
            st.stop()
    else:
        valores = [cenizas_bs, sio2, al2o3, fe2o3, cao, mgo, so3, na2o, k2o, s_carbon, cl_carbon]

    valores_np = np.array(valores).reshape(1, -1)
    pc_predicho = modelo.predict(valores_np)[0]
    pc_entero = int(round(pc_predicho))

    # Mostrar resultado
    st.success(f"ğŸ”¥ Poder CalorÃ­fico Predicho: **{pc_entero} kcal/kg**")

    # Guardar en historial
    nuevo = pd.DataFrame([{
        "FechaHora": datetime.datetime.now(pytz.timezone('America/Lima')).strftime('%Y-%m-%d %H:%M:%S'),  # Hora de PerÃº, formato string
        "Cenizas": valores[0],
        "PC": pc_entero
    }])
    historial = pd.read_csv(historial_path)
    historial = pd.concat([historial, nuevo], ignore_index=True).tail(20)
    historial.to_csv(historial_path, index=False)

    # Filtrar los datos de los Ãºltimos 3 dÃ­as
    fecha_3_dias_atras = datetime.datetime.now(pytz.timezone('America/Lima')) - datetime.timedelta(days=3)

    # Convertir 'FechaHora' a tipo datetime (sin modificar el formato, solo convertir la zona horaria)
    historial["FechaHora"] = pd.to_datetime(historial["FechaHora"], errors='coerce')
    historial["FechaHora"] = historial["FechaHora"].dt.tz_localize('UTC').dt.tz_convert('America/Lima')  # Convertir a la zona horaria de PerÃº

    # Asegurarse de que 'fecha_3_dias_atras' tambiÃ©n estÃ© en formato datetime
    fecha_3_dias_atras = pd.to_datetime(fecha_3_dias_atras)

    # Filtrar los datos de los Ãºltimos 3 dÃ­as
    historial_filtrado = historial[historial["FechaHora"] >= fecha_3_dias_atras] if not historial.empty else historial

    # Mostrar grÃ¡fico
    st.subheader("ğŸ“ˆ Historial de Predicciones")
    fig = px.scatter(historial_filtrado, x="FechaHora", y="PC",
                     size="Cenizas", color="Cenizas",
                     hover_data=["Cenizas", "PC"],
                     title="Predicciones de Poder CalorÃ­fico vs Cenizas",
                     labels={"PC": "Poder CalorÃ­fico (kcal/kg)", "FechaHora": "Hora"},
                     template="plotly_dark")

    fig.update_traces(mode="markers+lines")
    st.plotly_chart(fig, use_container_width=True)

    # Mostrar historial de predicciones
    st.subheader("ğŸ“œ Historial de Predicciones")
    st.dataframe(historial_filtrado)

    # Verificar si el historial estÃ¡ vacÃ­o
    if len(historial_filtrado) > 0:
        # Seleccionar Ã­ndice para eliminar
        indice_a_eliminar = st.number_input("Ingrese el Ã­ndice del punto a eliminar",
                                            min_value=0,
                                            max_value=len(historial_filtrado)-1,
                                            label="Ãndice del punto a eliminar")

        # BotÃ³n para eliminar el punto seleccionado
        if st.button("ğŸ—‘ï¸ Eliminar punto del historial"):
            if 0 <= indice_a_eliminar < len(historial_filtrado):
                historial_filtrado = historial_filtrado.drop(historial_filtrado.index[indice_a_eliminar])
                historial_filtrado.to_csv(historial_path, index=False)
                st.success(f"âœ… Punto en el Ã­ndice {indice_a_eliminar} eliminado correctamente.")

                # Mostrar el grÃ¡fico actualizado
                fig = px.scatter(historial_filtrado, x="FechaHora", y="PC",
                                 size="Cenizas", color="Cenizas",
                                 hover_data=["Cenizas", "PC"],
                                 title="Predicciones de Poder CalorÃ­fico vs Cenizas",
                                 labels={"PC": "Poder CalorÃ­fico (kcal/kg)", "FechaHora": "Hora"},
                                 template="plotly_dark")

                fig.update_traces(mode="markers+lines")
                st.plotly_chart(fig, use_container_width=True)
            else:
                st.error("âš ï¸ El Ã­ndice ingresado no es vÃ¡lido.")
    else:
        st.warning("âš ï¸ No hay predicciones en el historial para eliminar.")